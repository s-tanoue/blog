---
slug: ddd-layered-architecture
title: DDDレイヤードアーキテクチャのフォルダ構成ガイド
authors:
  name: Blog Maintainer
  title: Maintainer
  url: https://example.com
  image_url: https://avatars.githubusercontent.com/u/1?v=4
---

DDD（ドメイン駆動設計）は「ビジネスルールを中心にアプリケーションを組み立てる」ための考え方です。しかし、レイヤーの役割が曖昧なままフォルダを分けても、どこに何を書けばよいのか分からなくなりがちです。この記事では、典型的なフォルダ構成を示しつつ、各レイヤーの責務と依存関係を丁寧に説明します。

<!--truncate-->

## レイヤー間の関係を把握しよう

DDD のレイヤードアーキテクチャは「内側ほどビジネス寄り」「外側ほどインフラ寄り」という同心円のようなイメージです。内側のレイヤーは外側に依存しません。逆に外側は内側に依存しても構いません（ドメイン層を参照する REST コントローラなど）。

```text
src/
├── application/   # ユースケースをまとめる（内側から2番目）
├── domain/        # ビジネスルールの中心（最も内側）
├── infrastructure/ # 技術的詳細（内側を支える外側）
└── interface/     # ユーザーや他システムとの窓口（最も外側）
```

この向きを押さえておくと「ドメインルールに影響を与えずに外側を差し替える」設計がしやすくなります。

---

## domain レイヤー：システムの心臓部

**目的：** ビジネスのルールと概念を表現すること。外部技術に依存せず、純粋なオブジェクトや関数で構成します。

- **model/entity/**: ID を持つ存在。例：`Order`、`User`。振る舞いもここに持たせます。
- **model/value_object/**: 値の同一性が重要な概念。例：`EmailAddress`、`Money`。不変にしてロジックを閉じ込めましょう。
- **model/aggregate/**: 一貫性の境界。`Order` とその `OrderLine` をまとめて扱うなど、まとまりで整合性を保ちます。
- **repository/**: ドメインオブジェクトを保存・取得するためのインターフェイス。ここでは「契約」だけ定義し、実装は infrastructure に任せます。
- **service/**: 単一エンティティで完結しないビジネスルールを表現。ドメイン層内で完結する計算や整合チェックを行います。

> **ポイント**: ドメイン層から他レイヤーを参照しないこと。たとえば、HTTP ライブラリや DB クライアントを import してはいけません。

---

## application レイヤー：ユースケースを調整する

**目的：** ユーザーストーリーを実現するためにドメインオブジェクトを「どう組み合わせるか」を記述します。ビジネスルールはドメイン層に委ね、アプリケーション層では手続きの流れやトランザクション制御、他レイヤーとの連携を扱います。

- **service/**: `PlaceOrderService` のようなアプリケーションサービス。ドメインサービスやエンティティを呼び出し、結果をまとめます。
- **command/** / **query/**: CQRS を採用する場合、入力 DTO やハンドラを分けて配置します。書き込み（Command）と読み取り（Query）で責務を明示できます。
- **dto/**: UI や API から受け取る／返すデータ構造。ドメイン層のオブジェクトをそのまま晒さないための緩衝材です。

> **よくある疑問**: 「トランザクション制御はどこ？」 → アプリケーションサービスで行います。`@Transactional` のようなアノテーションはこのレイヤーに付きます。

---

## infrastructure レイヤー：技術的な詳細をまとめる

**目的：** DB、外部 API、メッセージングなど具体的な技術と接続します。ドメインやアプリケーションで定義したインターフェイスの実装を置きます。

- **persistence/**: RDB や NoSQL へのリポジトリ実装、ORマッパーのマッピング設定など。
- **external_api/**: 他サービスとの通信クライアント。リトライやサーキットブレーカーの設定もここに集めます。
- **configuration/**: DI コンテナ設定、アプリケーション設定読み込み、メッセージブローカー接続など。

> **依存方向に注意**: infrastructure からドメイン層のインターフェイスを実装する場合、`implements DomainRepository` のように「内側の契約に従う」形になります。

---

## interface レイヤー：利用者と会話する窓口

**目的：** HTTP、CLI、イベントなどさまざまな I/O とアプリケーション層をつなぐ役割です。入力のバリデーションや認証認可を行い、アプリケーションサービスを呼び出します。

- **rest/** / **graphql/**: コントローラやリゾルバ。ルーティング、リクエスト変換、レスポンス作成を担当します。
- **cli/**: バッチや運用コマンドなど、コマンドラインからアプリケーション層を呼び出すコード。
- **event/**: メッセージング基盤向けのパブリッシャ／サブスクライバ。受信イベントをアプリケーション層に渡し、発生したドメインイベントを外へ伝えます。

> **コツ**: interface レイヤーでビジネスロジックを書かないようにしましょう。認証や入力変換を済ませたらアプリケーションサービスに処理を委譲します。

---

## 典型的な処理の流れ

1. REST コントローラ（interface）が HTTP リクエストを受け取り、入力 DTO を作成。
2. アプリケーションサービス（application）が DTO を検証し、必要なドメインリポジトリを呼び出す。
3. ドメインエンティティ／サービス（domain）がビジネスルールを実行し、結果を返す。
4. アプリケーションサービスが結果を整形し、必要に応じてインフラ実装（infrastructure）を呼び出して永続化や外部連携を行う。
5. interface レイヤーがレスポンス DTO を返却。

このように責務を分けることで「どこにコードを書けばよいか」が明確になり、変更点を局所化できます。

---

## まとめと運用のヒント

- 新しい機能を追加するときは、まずドメイン層で必要な概念・ルールを整理する。
- アプリケーション層でユースケースを実装し、外部入出力は interface と infrastructure に閉じ込める。
- レイヤー間の依存は内から外へ一方向。外側の事情（DB、API の仕様）が変わっても内側のモデルは影響を受けにくくなります。

フォルダ構成はあくまでガイドラインです。チームの規模やプロダクトの性質に合わせてサブディレクトリを調整しつつ、レイヤーの役割がぶれないように命名と配置を工夫しましょう。
