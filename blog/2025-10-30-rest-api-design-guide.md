---
slug: rest-api-design-guide
title: REST API設計ガイド：基礎から実践まで
authors:
  name: Blog Maintainer
  title: Maintainer
  url: https://example.com
  image_url: https://avatars.githubusercontent.com/u/1?v=4
---

REST APIは現代のWebアプリケーションにおいて、システム間連携の標準的な方式となっています。しかし「RESTとは何か」を正しく理解せずに設計すると、保守性が低く使いにくいAPIになってしまいます。この記事では、RESTの基礎概念から具体的な設計原則、良い構造のAPI設計まで体系的に解説します。

<!--truncate-->

## RESTとは何か

REST（Representational State Transfer）は、Roy Fieldingが2000年の博士論文で提唱した、分散システムのアーキテクチャスタイルです。単なる技術仕様ではなく、スケーラブルで保守可能なWebサービスを構築するための「考え方」を示しています。

RESTの特徴は以下の原則に基づいています：

- **統一インターフェイス**: すべてのリソースに対して、一貫した操作方法を提供
- **クライアント・サーバー分離**: UIとデータストレージを独立させることで、それぞれの進化を促進
- **ステートレス**: 各リクエストは独立しており、サーバーはクライアントの状態を保持しない
- **キャッシュ可能**: レスポンスにキャッシュ可否を明示し、効率を向上
- **階層化システム**: 中間層（ロードバランサー、プロキシ）を透過的に配置可能

これらの原則を守ることで、拡張性が高く、変更に強いAPIを実現できます。

---

## リソース指向設計の考え方

REST APIの核心は「リソース」です。リソースとは、システムが扱うデータや概念の単位であり、それぞれが一意のURIで識別されます。

### リソースの粒度を決める

```text
良い例：
GET /users         # ユーザー一覧
GET /users/123     # 特定のユーザー
GET /users/123/orders  # 特定ユーザーの注文一覧

避けるべき例：
GET /getUserList
POST /createNewUser
GET /getOrdersByUserId?userId=123
```

ポイントは「動詞ではなく名詞でリソースを表現する」ことです。操作（取得、作成、更新、削除）はHTTPメソッドで表現します。

### リソースの階層構造

リソース間の関係を階層で表現すると、APIの意図が明確になります：

```text
/organizations/456/teams/789/members
```

ただし、深すぎる階層（4階層以上）は避けましょう。複雑な関係は別リソースとして独立させるか、クエリパラメータで絞り込む方が扱いやすくなります。

---

## HTTPメソッドの正しい使い方

各HTTPメソッドには明確な意味があり、それに従うことでAPIの一貫性が保たれます。

### 主要なメソッドと用途

| メソッド | 用途 | 冪等性 | 安全性 |
|---------|------|--------|--------|
| **GET** | リソースの取得 | ✓ | ✓ |
| **POST** | リソースの作成 | × | × |
| **PUT** | リソースの完全な置き換え | ✓ | × |
| **PATCH** | リソースの部分更新 | △ | × |
| **DELETE** | リソースの削除 | ✓ | × |

**冪等性**とは、同じリクエストを複数回実行しても同じ結果になること。**安全性**は、リソースの状態を変更しないことを意味します。

### 具体例

```http
# 新規ユーザー作成
POST /users
Content-Type: application/json

{
  "name": "田中太郎",
  "email": "tanaka@example.com"
}

# ユーザー情報の完全更新
PUT /users/123
Content-Type: application/json

{
  "name": "田中花子",
  "email": "hanako@example.com",
  "role": "admin"
}

# メールアドレスだけ更新
PATCH /users/123
Content-Type: application/json

{
  "email": "newemail@example.com"
}

# ユーザー削除
DELETE /users/123
```

> **POSTとPUTの使い分け**: クライアントがリソースのURIを決められる場合はPUT、サーバー側でURIを割り当てる場合はPOSTを使います。

---

## ステータスコードで意図を伝える

HTTPステータスコードを適切に使うことで、APIの挙動がクライアントに明確に伝わります。

### 成功系（2xx）

- **200 OK**: リクエスト成功、レスポンスボディあり
- **201 Created**: リソース作成成功、`Location`ヘッダーで新リソースのURIを返す
- **204 No Content**: 成功したがレスポンスボディなし（DELETE、更新後など）

### クライアントエラー（4xx）

- **400 Bad Request**: リクエストの形式が不正
- **401 Unauthorized**: 認証が必要または失敗
- **403 Forbidden**: 認証済みだが権限不足
- **404 Not Found**: リソースが存在しない
- **409 Conflict**: リソースの状態と矛盾する操作
- **422 Unprocessable Entity**: 形式は正しいが、ビジネスルール違反

### サーバーエラー（5xx）

- **500 Internal Server Error**: 予期しないサーバー側エラー
- **503 Service Unavailable**: 一時的に利用不可（メンテナンスなど）

```http
HTTP/1.1 201 Created
Location: /users/456
Content-Type: application/json

{
  "id": 456,
  "name": "田中太郎",
  "email": "tanaka@example.com",
  "createdAt": "2025-10-30T10:00:00Z"
}
```

---

## エラーレスポンスの設計

エラーが発生したとき、クライアントが問題を理解し対処できる情報を返すことが重要です。

### 推奨されるエラーレスポンス形式

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "入力内容に誤りがあります",
    "details": [
      {
        "field": "email",
        "message": "メールアドレスの形式が不正です"
      },
      {
        "field": "age",
        "message": "年齢は0以上である必要があります"
      }
    ]
  }
}
```

- **code**: プログラムで判定可能なエラー識別子
- **message**: 人間が読めるエラー説明
- **details**: フィールドレベルの詳細情報（バリデーションエラーなど）

---

## バージョニング戦略

APIは進化します。後方互換性を保ちつつ新機能を追加するため、バージョン管理が必要です。

### 主なバージョニング方式

1. **URLパス方式**（推奨）

```text
/v1/users
/v2/users
```

明確で、プロキシやキャッシュ層でも扱いやすい。

2. **ヘッダー方式**

```http
GET /users
Accept: application/vnd.myapi.v2+json
```

URIを汚さないが、デバッグやテストがやや煩雑。

3. **クエリパラメータ方式**

```text
/users?version=2
```

簡単だが、キャッシュの扱いが複雑になる可能性。

> **破壊的変更とは**: フィールド削除、型の変更、必須パラメータの追加など、既存クライアントが動かなくなる変更。これを避けるため、フィールド追加や新エンドポイント追加は同じバージョン内で行います。

---

## ページネーションとフィルタリング

大量データを返すエンドポイントでは、ページネーションが必須です。

### オフセット方式

```http
GET /users?offset=20&limit=10

{
  "data": [...],
  "pagination": {
    "offset": 20,
    "limit": 10,
    "total": 150
  }
}
```

シンプルだが、データ挿入時にページがずれる欠点があります。

### カーソル方式

```http
GET /users?cursor=eyJpZCI6MTIzfQ&limit=10

{
  "data": [...],
  "pagination": {
    "nextCursor": "eyJpZCI6MTMzfQ",
    "hasMore": true
  }
}
```

データが追加されても一貫性が保たれ、大規模データに適しています。

### フィルタリングとソート

```http
GET /users?role=admin&sortBy=createdAt&order=desc
```

クエリパラメータで検索条件を指定します。複雑な条件が必要な場合はPOSTメソッドで検索用エンドポイントを作ることも検討しましょう。

---

## セキュリティの考慮

REST APIは公開インターフェイスであり、セキュリティ対策が不可欠です。

### 認証・認可

- **OAuth 2.0 / OpenID Connect**: 標準的な認証プロトコル
- **JWT（JSON Web Token）**: ステートレスなトークンベース認証
- **APIキー**: シンプルだが、キーの管理と定期的なローテーションが重要

### HTTPS必須

すべての通信をHTTPSで暗号化し、中間者攻撃を防ぎます。

### レート制限

```http
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 999
X-RateLimit-Reset: 1635724800
```

過度なリクエストを制限し、サービスの安定性を保ちます。

### 入力検証

- クライアント側だけでなく、サーバー側でも必ず検証
- SQLインジェクション、XSSなどの攻撃を防ぐ
- 予期しない巨大データを拒否

---

## ドキュメント化とテスト

### OpenAPI（Swagger）でドキュメント化

```yaml
openapi: 3.0.0
info:
  title: User API
  version: 1.0.0
paths:
  /users:
    get:
      summary: ユーザー一覧取得
      responses:
        '200':
          description: 成功
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/User'
```

OpenAPI仕様書があれば、クライアントSDKの自動生成やモックサーバーの構築が容易になります。

### APIテスト

- **単体テスト**: 各エンドポイントの正常系、異常系
- **統合テスト**: 認証、データベース連携を含めた動作確認
- **契約テスト**: クライアントとサーバーの期待値が一致しているか検証

---

## 実践的な設計のヒント

### 1. 一貫性を保つ

- 命名規則（スネークケース or キャメルケース）
- エラーレスポンス形式
- ページネーション方式

これらをAPI全体で統一すると、学習コストが下がり使いやすくなります。

### 2. 過度な最適化を避ける

初めから完璧なAPIを作ろうとせず、シンプルに始めて、フィードバックをもとに進化させましょう。

### 3. クライアント目線で考える

APIを実際に使う開発者の立場に立ち、直感的で分かりやすいインターフェイスを心がけます。

### 4. 変更履歴を記録

CHANGELOGを維持し、どのバージョンで何が変わったのかを明記すると、クライアント側の移行がスムーズになります。

---

## まとめ

REST APIの設計で押さえるべきポイント：

- リソース指向の思考でURIを設計
- HTTPメソッドとステータスコードを正しく使う
- エラーレスポンスに十分な情報を含める
- バージョニングで後方互換性を保つ
- ページネーション、フィルタリングで大量データに対応
- セキュリティを最初から組み込む
- OpenAPIでドキュメント化し、テストを自動化

良いAPIは、使う人にとって「予測可能」で「一貫性がある」ものです。RESTの原則に従いながら、実際のユースケースに合わせて柔軟に設計していきましょう。
