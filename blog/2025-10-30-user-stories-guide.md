---
slug: user-stories-guide
title: バックログの作り方とユーザーストーリーの書き方
authors:
  name: Agile Writer
  title: プロダクトマネージャー
  url: https://example.com/authors/agile-writer
  image_url: https://avatars.githubusercontent.com/u/2?v=4
---

効果的なバックログを作成し、チームが価値を素早く届けるためには、良質なユーザーストーリーが欠かせません。本記事では、ユーザーストーリーの書き方、INVEST原則、受け入れ基準の作り方、そしてタスクとストーリーの切り分け方について解説します。

## ユーザーストーリーとは

ユーザーストーリーは、ユーザーの視点から表現された機能要求です。技術的な詳細ではなく、「誰が」「何を」「なぜ」必要としているのかを明確にすることで、チームが価値に焦点を当てて開発できるようにします。

基本的な形式:
```
[ユーザータイプ]として、
[目的]のために、
[機能]が欲しい
```

例:
```
ECサイトの購入者として、
購入履歴を確認したいので、
マイページから過去の注文一覧を見られる機能が欲しい
```

## INVEST原則 - 良いユーザーストーリーの条件

INVEST原則は、質の高いユーザーストーリーを書くための6つの基準です。

### I - Independent（独立している）

ストーリーは他のストーリーに依存せず、独立して実装・テスト・リリースできることが理想です。依存関係が多いと、優先順位の調整やスプリント計画が困難になります。

**良い例:**
- ストーリーA: 「ユーザーとして、商品をカートに追加できる」
- ストーリーB: 「ユーザーとして、カート内の商品を削除できる」

**改善が必要な例:**
- ストーリーA: 「決済システムのAPI設計」
- ストーリーB: 「決済システムのAPI実装」（AなしではBが実装できない）

**改善案:** 「ユーザーとして、クレジットカードで決済できる」として1つのストーリーにまとめる

### N - Negotiable（交渉可能）

ストーリーは詳細な仕様書ではなく、会話のきっかけです。実装方法や詳細は開発チームとプロダクトオーナーが対話しながら決めていきます。

**良い例:**
```
ユーザーとして、
商品検索をしたいので、
キーワードで商品を絞り込める機能が欲しい
```
→ 検索アルゴリズムや表示件数は開発時に議論可能

**改善が必要な例:**
```
PostgreSQLのフルテキスト検索を使い、
トリグラムインデックスを作成して、
類似度0.3以上の結果を20件表示する
```
→ 技術的詳細を固定しすぎており、交渉の余地がない

### V - Valuable（価値がある）

すべてのストーリーは、ユーザーやビジネスに明確な価値を提供する必要があります。技術的な作業だけで構成されたストーリーは避けましょう。

**良い例:**
```
モバイルユーザーとして、
外出先でも注文状況を確認したいので、
スマートフォンから注文履歴を見られる機能が欲しい
```
→ ユーザーへの価値が明確

**改善が必要な例:**
```
開発者として、
データベースのインデックスを最適化したい
```
→ 技術的な作業に終始している

**改善案:**
```
ユーザーとして、
ストレスなく商品を探したいので、
検索結果が1秒以内に表示される機能が欲しい
```
→ パフォーマンス改善の価値を明確にする

### E - Estimable（見積もり可能）

開発チームがストーリーのサイズや工数を見積もれる程度に具体的である必要があります。曖昧すぎる、または大きすぎるストーリーは分割が必要です。

**見積もりを困難にする要因:**
- ストーリーが大きすぎる（エピックレベル）
- 要件が不明瞭
- 技術的な不確実性が高い

**対策:**
- リファインメントで詳細を明確化
- 技術調査のスパイク（調査タスク）を先に実施
- 大きなストーリーを複数の小さなストーリーに分割

### S - Small（小さい）

ストーリーは1スプリント内で完了できるサイズに収めます。理想的には、数日で完成するサイズです。小さいストーリーは、早くフィードバックを得られ、リスクも低減できます。

**大きすぎる例（エピック）:**
```
ユーザーとして、
オンラインで商品を購入できる機能が欲しい
```

**適切なサイズに分割:**
1. 「ユーザーとして、商品をカートに追加できる」
2. 「ユーザーとして、カート内容を確認・編集できる」
3. 「ユーザーとして、配送先情報を入力できる」
4. 「ユーザーとして、クレジットカードで決済できる」
5. 「ユーザーとして、注文完了メールを受信できる」

### T - Testable（テスト可能）

ストーリーが完成したかどうかを客観的に確認できる必要があります。曖昧な表現は避け、受け入れ基準を明確にします。

**テストしにくい例:**
```
ユーザーとして、
使いやすいUIで商品を検索したい
```
→ 「使いやすい」は主観的で測定困難

**テスト可能な改善案:**
```
ユーザーとして、
商品名でキーワード検索し、
関連する商品一覧を見られる機能が欲しい

受け入れ基準:
- 検索フィールドにキーワードを入力できる
- 商品名に部分一致する商品が表示される
- 検索結果は関連度順に並ぶ
- 該当商品がない場合は「見つかりませんでした」と表示される
```

## 受け入れ基準（Acceptance Criteria）の作り方

受け入れ基準は、ユーザーストーリーが「完成」したと判断するための具体的な条件です。チームとステークホルダーの間で完成のイメージを合わせ、テストの基準にもなります。

### Given-When-Then形式

**フォーマット:**
```
Given（前提条件）
When（操作）
Then（期待される結果）
```

**例: ログイン機能**
```
ユーザーストーリー:
登録済みユーザーとして、
アカウントにアクセスしたいので、
メールアドレスとパスワードでログインできる機能が欲しい

受け入れ基準:

シナリオ1: 正しい認証情報でのログイン
Given: ユーザーがログインページにいる
And: 有効なアカウントを持っている
When: 正しいメールアドレスとパスワードを入力する
And: ログインボタンをクリックする
Then: ダッシュボードページにリダイレクトされる
And: ユーザー名がヘッダーに表示される

シナリオ2: 間違ったパスワードでのログイン
Given: ユーザーがログインページにいる
When: 正しいメールアドレスと間違ったパスワードを入力する
And: ログインボタンをクリックする
Then: エラーメッセージ「メールアドレスまたはパスワードが正しくありません」が表示される
And: ログインページにとどまる

シナリオ3: 空欄でのログイン試行
Given: ユーザーがログインページにいる
When: メールアドレスまたはパスワードを空欄のままにする
And: ログインボタンをクリックする
Then: 「このフィールドは必須です」というエラーメッセージが表示される
```

### チェックリスト形式

シンプルなストーリーには、箇条書きの受け入れ基準も有効です。

**例: 商品検索機能**
```
ユーザーストーリー:
ECサイトの訪問者として、
欲しい商品を素早く見つけたいので、
キーワードで商品を検索できる機能が欲しい

受け入れ基準:
- [ ] 検索フィールドがヘッダーに表示されている
- [ ] キーワードを入力して検索できる
- [ ] 商品名に部分一致する商品が表示される
- [ ] 検索結果には商品画像、名前、価格が表示される
- [ ] 該当商品がない場合は「該当する商品が見つかりませんでした」と表示される
- [ ] 検索結果は10件ずつページネーションされる
- [ ] 空欄で検索した場合は全商品が表示される
```

### 良い受け入れ基準のポイント

1. **具体的で明確**: 誰が読んでも同じ理解ができる
2. **テスト可能**: 合格/不合格を客観的に判断できる
3. **ユーザー視点**: ユーザーが得られる価値に焦点を当てる
4. **完全性**: 主要なシナリオとエッジケースをカバーする
5. **独立性**: 他のストーリーの詳細に依存しない

## ユーザーストーリーの具体例

### 例1: ソーシャルメディアアプリの「いいね」機能

```
ユーザーストーリー:
アプリユーザーとして、
気に入った投稿に反応を示したいので、
投稿に「いいね」をつける機能が欲しい

受け入れ基準:
- 各投稿に「いいね」ボタンが表示される
- ボタンをタップすると「いいね」がつけられる
- もう一度タップすると「いいね」を取り消せる
- 「いいね」の総数が表示される
- 自分が「いいね」した投稿にはハイライト表示される
- ネットワークエラー時は適切なメッセージが表示される
```

### 例2: 予約システムの通知機能

```
ユーザーストーリー:
予約をしたユーザーとして、
予約を忘れないように、
予約の1日前にリマインダー通知を受け取りたい

受け入れ基準:
Given: ユーザーが予約を確定している
And: 通知設定がオンになっている
When: 予約日時の24時間前になる
Then: プッシュ通知が送信される
And: 通知には予約日時、場所、サービス名が含まれる
And: 通知をタップすると予約詳細画面が開く

境界条件:
- 予約の24時間前が深夜の場合は午前9時に送信される
- 通知設定がオフの場合は送信されない
- 複数の予約がある場合はそれぞれ個別に通知される
```

### 例3: データ分析ツールのエクスポート機能

```
ユーザーストーリー:
データアナリストとして、
分析結果を社内で共有したいので、
レポートをCSV形式でエクスポートできる機能が欲しい

受け入れ基準:
- レポート画面に「エクスポート」ボタンが表示される
- ボタンをクリックするとCSVファイルがダウンロードされる
- CSVには表示されているすべてのデータが含まれる
- CSVのヘッダー行にはカラム名が入る
- ファイル名は「レポート名_YYYYMMDD.csv」の形式
- 大量データ（10,000行以上）でもタイムアウトしない
- エクスポート中はローディングインジケーターが表示される
- 日本語データが文字化けせずに出力される（UTF-8 BOM付き）
```

## タスクとストーリーの切り分け方

ユーザーストーリーとタスクは異なる概念です。混同すると、バックログの優先順位付けや価値の可視化が難しくなります。

### ユーザーストーリー vs タスク

| 観点 | ユーザーストーリー | タスク |
|------|------------------|--------|
| **視点** | ユーザー視点 | 開発者視点 |
| **価値** | ユーザーやビジネスへの価値 | 技術的な実装単位 |
| **粒度** | スプリントで完成する機能単位 | 数時間〜数日の作業単位 |
| **記述者** | プロダクトオーナー | 開発チーム |
| **管理場所** | プロダクトバックログ | スプリントバックログ |
| **優先順位** | ビジネス価値で決まる | ストーリー実現のための順序で決まる |

### 切り分けの例

**ユーザーストーリー:**
```
モバイルユーザーとして、
外出先でも商品を購入したいので、
スマートフォンからカート機能を使える
```

**このストーリーを実現するためのタスク（開発チームが作成）:**
1. モバイル向けのカートUIコンポーネントを実装する
2. カートAPIエンドポイントをモバイル対応する
3. レスポンシブデザインのCSS調整
4. タッチ操作のジェスチャー対応
5. モバイルブラウザでのテスト
6. iOS/Androidでの動作確認

### ストーリーにできない技術的作業の扱い方

技術的負債の返済やインフラ改善など、直接ユーザー価値に繋がりにくい作業は、次のように扱います。

#### 1. 技術的ストーリー（Technical Story）として表現

価値を明確にして書きます:

**悪い例:**
```
開発者として、
データベースのインデックスを追加したい
```

**良い例:**
```
すべてのユーザーとして、
商品一覧の表示を待たずにストレスなく買い物をしたいので、
商品検索が1秒以内に応答する
```
→ パフォーマンス改善という価値を明確にする

#### 2. イネーブラーストーリー（Enabler Story）

将来のストーリーを実現するための基盤作りは、イネーブラーとして管理:

```
開発チームとして、
今後の機能拡張を効率的に進めたいので、
認証システムをOAuth 2.0に移行する

価値:
- ソーシャルログインの実装が容易になる
- セキュリティが向上する
- サードパーティ連携の準備ができる
```

#### 3. Definition of Done（完成の定義）に含める

バグ修正やリファクタリングは、すべてのストーリーの完成条件に含めます:

```
完成の定義:
- すべてのテストが通る
- コードレビューが承認されている
- ドキュメントが更新されている
- パフォーマンステストが通る
- セキュリティスキャンで問題がない
```

### 判断の目安

**ストーリーとして扱うべき:**
- ユーザーが直接触れる機能や改善
- ビジネス価値が明確な変更
- ステークホルダーに説明が必要なもの

**タスクとして扱うべき:**
- ストーリーを実現するための実装手順
- 開発チーム内で完結する技術的作業
- 数時間〜数日で完了する作業単位

## バックログ管理のベストプラクティス

### 1. ストーリーマッピングで全体像を把握

ユーザージャーニーに沿ってストーリーを並べ、リリース計画を立てます。横軸に時系列、縦軸に優先順位を配置することで、MVP（最小実行可能製品）を明確にできます。

### 2. リファインメントで継続的に磨く

スプリント中に1〜2時間、バックログリファインメント（グルーミング）の時間を取ります:
- 上位のストーリーを詳細化
- 大きなストーリーを分割
- 受け入れ基準を追加
- 見積もりを更新

### 3. MoSCoW法で優先順位を明確化

- **Must have（必須）**: これがないと価値が届かない
- **Should have（重要）**: できるだけ含めたいが必須ではない
- **Could have（あれば良い）**: 余裕があれば追加
- **Won't have（今回は対象外）**: 将来的に検討

### 4. ストーリーポイントで相対見積もり

時間ではなく複雑さで見積もります:
- フィボナッチ数列（1, 2, 3, 5, 8, 13...）を使用
- 基準となるストーリー（例: 2ポイント）と比較
- チームのベロシティ（スプリントごとの完了ポイント）を測定

### 5. スパイクで不確実性を減らす

技術的な不確実性が高い場合、調査専用のスパイクを実施:
```
スパイク: 外部決済APIの調査
タイムボックス: 2日間
ゴール:
- 候補となる決済サービス3つを比較
- 統合の複雑さを評価
- 推奨案を提示
```

## まとめ

良いユーザーストーリーは、チームとステークホルダーをつなぎ、価値創造に集中させる強力なツールです:

1. **INVEST原則**を意識して、独立性・交渉可能性・価値・見積もり可能性・小ささ・テスト可能性を確保する
2. **受け入れ基準**をGiven-When-Then形式やチェックリストで明確にし、完成の定義を合わせる
3. **ストーリーとタスクを切り分け**、バックログにはユーザー価値を持つストーリーを配置し、タスクはスプリント計画時に作成する
4. **継続的なリファインメント**で、バックログを常に最新の学びと優先順位に合わせて更新する

効果的なバックログ管理は、スクラムチームの生産性と価値提供の質を大きく向上させます。まずは小さく始めて、チームで振り返りながら改善を重ねていきましょう。
